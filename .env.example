# Decentralized Sequencer Environment Variables
# Copy this file to .env and configure as needed

# ============================================
# CORE CONFIGURATION
# ============================================

# Unique identifier for this sequencer instance
SEQUENCER_ID=unified-sequencer-1

# P2P port for libp2p networking
P2P_PORT=9001

# Redis connection string
REDIS_ADDR=localhost:6379
# For Docker: use redis:6379

# ============================================
# P2P NETWORK CONFIGURATION
# ============================================

# Bootstrap node multiaddr (REQUIRED for P2P)
# Format: /ip4/<IP>/tcp/<PORT>/p2p/<PEER_ID>
# Example: /ip4/YOUR.SERVER.IP.HERE/tcp/9100/p2p/YOUR_PEER_ID_HERE
BOOTSTRAP_MULTIADDR=

# Private key for P2P identity (optional - will generate if not provided)
# Format: hex-encoded Ed25519 private key
# Leave empty to generate a new key on each start
PRIVATE_KEY=

# ============================================
# COMPONENT TOGGLES
# ============================================

# Enable/disable individual components (true/false)
ENABLE_LISTENER=true      # P2P gossipsub listener
ENABLE_DEQUEUER=true      # Redis queue processor
ENABLE_FINALIZER=true     # Batch finalizer
ENABLE_CONSENSUS=true     # Consensus voting

# ============================================
# DEQUEUER CONFIGURATION
# ============================================

# Number of concurrent dequeue workers
DEQUEUER_WORKERS=5

# For Docker Compose scaling (number of dequeuer containers)
DEQUEUER_REPLICAS=3

# ============================================
# FINALIZER CONFIGURATION 
# (ONLY NEEDED IF ENABLE_FINALIZER=true)
# ============================================
# The finalizer component handles batch finalization and storage
# These settings are inherited from the centralized sequencer
# and are NOT needed for basic submission listening/processing

# Number of finalizer instances (for redundancy)
FINALIZER_REPLICAS=2

# Storage provider: ipfs, arweave, filecoin
# NOTE: Requires corresponding storage service to be running
STORAGE_PROVIDER=ipfs

# IPFS node address (ONLY if using IPFS for finalized batch storage)
# You need to run an IPFS node separately if finalizer is enabled
IPFS_HOST=localhost:5001
# For Docker: use ipfs:5001

# Data availability layer: none, eigenda, celestia, avail
# For future integration with DA layers
DA_PROVIDER=none

# ============================================
# BLOCKCHAIN CONFIGURATION
# ============================================

# Ethereum RPC URL (for on-chain interactions)
RPC_URL=https://eth-mainnet.g.alchemy.com/v2/YOUR_API_KEY

# Private key for on-chain transactions (hex format, no 0x prefix)
# IMPORTANT: Use different keys for different components in production
PRIVATE_KEY_ALL=
PRIVATE_KEY_LISTENER=
PRIVATE_KEY_FINALIZER=
PRIVATE_KEY_VAL1=
PRIVATE_KEY_VAL2=
PRIVATE_KEY_VAL3=

# ============================================
# DEBUGGING & MONITORING
# ============================================

# Enable debug logging (true/false)
DEBUG_MODE=false

# Metrics port for Prometheus
METRICS_PORT=9090

# ============================================
# QUICK START CONFIGURATIONS
# ============================================

# For LOCAL TESTING (everything on one machine):
# - Use defaults above
# - Set REDIS_ADDR=localhost:6379
# - Leave PRIVATE_KEY empty (will auto-generate)
# - Set DEBUG_MODE=true

# For DOCKER COMPOSE:
# - Set REDIS_ADDR=redis:6379
# - Set IPFS_HOST=ipfs:5001
# - Use the bootstrap multiaddr above

# For PRODUCTION:
# - Generate unique PRIVATE_KEY for each instance
# - Set proper RPC_URL with your API key
# - Set DEBUG_MODE=false
# - Configure STORAGE_PROVIDER and DA_PROVIDER as needed